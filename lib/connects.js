// Generated by CoffeeScript 1.6.3
(function() {
  var ConnectBase, ConnectNet, ConnectTCP, ConnectUnixSocket, protocol, utils, _ref, _ref1, _ref2,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    __slice = [].slice;

  protocol = require('./protocol');

  utils = require('./utils');

  ConnectBase = (function(_super) {
    __extends(ConnectBase, _super);

    function ConnectBase(options) {
      this.options = options != null ? options : {};
      this.connect = __bind(this.connect, this);
      this.handleOptions = __bind(this.handleOptions, this);
      this.verbose = __bind(this.verbose, this);
      this.debug = __bind(this.debug, this);
      this.connected = false;
      this.handleOptions();
      this.debug('ConnectBase::constructor');
      ConnectBase.__super__.constructor.call(this, this.options);
    }

    ConnectBase.prototype.debug = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.options.debug) {
        return (_ref = this.options).logFn.apply(_ref, ["" + this.constructor.name + "> "].concat(__slice.call(args)));
      }
    };

    ConnectBase.prototype.verbose = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.options.verbose) {
        return (_ref = this.options).logFn.apply(_ref, ["" + this.constructor.name + "> "].concat(__slice.call(args)));
      }
    };

    ConnectBase.prototype.handleOptions = function() {
      var _base, _base1, _base2;
      if ((_base = this.options).logFn == null) {
        _base.logFn = console.log;
      }
      if ((_base1 = this.options).verbose == null) {
        _base1.verbose = false;
      }
      if ((_base2 = this.options).debug == null) {
        _base2.debug = false;
      }
      return this.debug('handleOptions');
    };

    ConnectBase.prototype.connect = function() {
      if (this.socket == null) {
        throw new Error('socket does not exists');
      }
    };

    return ConnectBase;

  })(utils.PubSub);

  ConnectNet = (function(_super) {
    __extends(ConnectNet, _super);

    function ConnectNet() {
      this.onError = __bind(this.onError, this);
      this.onClose = __bind(this.onClose, this);
      this.onDisconnect = __bind(this.onDisconnect, this);
      this.handleLine = __bind(this.handleLine, this);
      this.onBuffer = __bind(this.onBuffer, this);
      this.onConnect = __bind(this.onConnect, this);
      this.disconnect = __bind(this.disconnect, this);
      this.send = __bind(this.send, this);
      this.connect = __bind(this.connect, this);
      _ref = ConnectNet.__super__.constructor.apply(this, arguments);
      return _ref;
    }

    ConnectNet.prototype.connect = function() {
      this.debug("ConnectNet::connect");
      ConnectNet.__super__.connect.apply(this, arguments);
      this.socket.on('connect', this.onConnect);
      this.socket.on('data', this.onBuffer);
      this.socket.on('end', this.onDisconnect);
      this.socket.on('error', this.onError);
      return this.socket.on('close', this.onClose);
    };

    ConnectNet.prototype.send = function(message, encoding, callback) {
      var data;
      if (encoding == null) {
        encoding = null;
      }
      if (callback == null) {
        callback = null;
      }
      if (typeof message === 'string') {
        data = "" + message + "\r\n";
      } else {
        data = message.join(" ") + "\r\n";
      }
      return this.socket.write(data, encoding, callback);
    };

    ConnectNet.prototype.disconnect = function() {
      this.socket.end();
      return this.onDisconnect();
    };

    ConnectNet.prototype.onConnect = function() {
      this.connected = true;
      this.debug("ConnectNet::onConnect");
      return this.emit('connect');
    };

    ConnectNet.prototype.onBuffer = function(buffer) {
      var line, _i, _len, _ref1, _results;
      this.debug('ConnectNet::onBuffer', buffer);
      this.emit('buffer', buffer);
      _ref1 = buffer.toString().split("\n");
      _results = [];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        line = _ref1[_i];
        _results.push(this.handleLine(line));
      }
      return _results;
    };

    ConnectNet.prototype.handleLine = function(line) {
      var message;
      line = line.replace(/^\s+|\s+$/g, "");
      if (!line.length) {
        return false;
      }
      this.debug('ConnectNet::handleLine', line);
      message = protocol.prototype.parseData(line);
      this.debug('protocol::parseData', message);
      this.emit('data', line);
      return this.emit('message', message);
    };

    ConnectNet.prototype.onDisconnect = function() {
      this.debug("ConnectNet::onDisconnect");
      this.connected = false;
      return this.emit('disconnect');
    };

    ConnectNet.prototype.onClose = function() {
      this.debug("ConnectNet::onClose");
      this.connected = false;
      return this.emit('disconnect');
    };

    ConnectNet.prototype.onError = function(error) {
      this.debug("ConnectNet::onError", error);
      return this.emit('error', error);
    };

    return ConnectNet;

  })(ConnectBase);

  ConnectTCP = (function(_super) {
    __extends(ConnectTCP, _super);

    function ConnectTCP() {
      this.connect = __bind(this.connect, this);
      this.handleOptions = __bind(this.handleOptions, this);
      _ref1 = ConnectTCP.__super__.constructor.apply(this, arguments);
      return _ref1;
    }

    ConnectTCP.prototype.handleOptions = function() {
      var _base, _base1, _base2;
      ConnectTCP.__super__.handleOptions.apply(this, arguments);
      if ((_base = this.options).host == null) {
        _base.host = 'ns-server.epitech.net';
      }
      if ((_base1 = this.options).port == null) {
        _base1.port = 4242;
      }
      return (_base2 = this.options).localAddress != null ? (_base2 = this.options).localAddress : _base2.localAddress = '0.0.0.0';
    };

    ConnectTCP.prototype.connect = function() {
      this.debug("ConnectTCP::connect");
      this.verbose("Connecting to " + this.options.host + ":" + this.options.port + "...");
      this.socket = require('net').connect({
        port: this.options.port,
        host: this.options.host,
        localAddress: this.options.localAddress
      });
      return ConnectTCP.__super__.connect.apply(this, arguments);
    };

    return ConnectTCP;

  })(ConnectNet);

  ConnectUnixSocket = (function(_super) {
    __extends(ConnectUnixSocket, _super);

    function ConnectUnixSocket() {
      this.connect = __bind(this.connect, this);
      this.handleOptions = __bind(this.handleOptions, this);
      _ref2 = ConnectUnixSocket.__super__.constructor.apply(this, arguments);
      return _ref2;
    }

    ConnectUnixSocket.prototype.handleOptions = function() {
      ConnectUnixSocket.__super__.handleOptions.apply(this, arguments);
      if (this.options.path == null) {
        throw new Error('unix socket not specified');
      }
    };

    ConnectUnixSocket.prototype.connect = function() {
      this.debug("ConnectUnixSocket::connect");
      this.verbose("Connecting to " + this.options.path + "...");
      this.socket = require('net').connect({
        path: this.options.path
      });
      return ConnectUnixSocket.__super__.connect.apply(this, arguments);
    };

    return ConnectUnixSocket;

  })(ConnectNet);

  module.exports = {
    unixSocket: ConnectUnixSocket,
    tcp: ConnectTCP,
    net: ConnectNet,
    base: ConnectBase
  };

}).call(this);
