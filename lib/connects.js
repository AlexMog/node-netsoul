// Generated by CoffeeScript 1.4.0
(function() {
  var ConnectBase, ConnectNet, ConnectTCP, ConnectUnixSocket, PubSub, protocol,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice,
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  protocol = require('./protocol');

  PubSub = (function() {

    function PubSub() {
      this.emit = __bind(this.emit, this);

      this.on = __bind(this.on, this);
      this.subs = {};
    }

    PubSub.prototype.on = function(event, callback, id) {
      if (id == null) {
        id = null;
      }
      if (!(this.subs[event] != null)) {
        this.subs[event] = [];
      }
      return this.subs[event].push({
        callback: callback,
        id: id
      });
    };

    PubSub.prototype.emit = function() {
      var args, event, subscription, _i, _len, _ref, _results;
      event = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if (!(this.subs[event] != null)) {
        return false;
      }
      _ref = this.subs[event];
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        subscription = _ref[_i];
        _results.push(subscription.callback.apply(subscription, args));
      }
      return _results;
    };

    return PubSub;

  })();

  ConnectBase = (function(_super) {

    __extends(ConnectBase, _super);

    function ConnectBase(options) {
      this.options = options != null ? options : {};
      this.connect = __bind(this.connect, this);

      this.handleOptions = __bind(this.handleOptions, this);

      this.verbose = __bind(this.verbose, this);

      this.debug = __bind(this.debug, this);

      this.connected = false;
      this.handleOptions();
      this.debug('ConnectBase::constructor');
      ConnectBase.__super__.constructor.call(this, this.options);
    }

    ConnectBase.prototype.debug = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.options.debug) {
        return (_ref = this.options).logFn.apply(_ref, ["" + this.constructor.name + "> "].concat(__slice.call(args)));
      }
    };

    ConnectBase.prototype.verbose = function() {
      var args, _ref;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.options.verbose) {
        return (_ref = this.options).logFn.apply(_ref, ["" + this.constructor.name + "> "].concat(__slice.call(args)));
      }
    };

    ConnectBase.prototype.handleOptions = function() {
      var _base, _base1, _base2, _ref, _ref1, _ref2;
      if ((_ref = (_base = this.options).logFn) == null) {
        _base.logFn = console.log;
      }
      if ((_ref1 = (_base1 = this.options).verbose) == null) {
        _base1.verbose = false;
      }
      if ((_ref2 = (_base2 = this.options).debug) == null) {
        _base2.debug = false;
      }
      return this.debug('handleOptions');
    };

    ConnectBase.prototype.connect = function() {
      if (!(this.socket != null)) {
        throw new Error('socket does not exists');
      }
    };

    return ConnectBase;

  })(PubSub);

  ConnectNet = (function(_super) {

    __extends(ConnectNet, _super);

    function ConnectNet() {
      this.onError = __bind(this.onError, this);

      this.onDisconnect = __bind(this.onDisconnect, this);

      this.handleLine = __bind(this.handleLine, this);

      this.onBuffer = __bind(this.onBuffer, this);

      this.onConnect = __bind(this.onConnect, this);

      this.disconnect = __bind(this.disconnect, this);

      this.send = __bind(this.send, this);

      this.connect = __bind(this.connect, this);
      return ConnectNet.__super__.constructor.apply(this, arguments);
    }

    ConnectNet.prototype.connect = function() {
      this.debug("ConnectNet::connect");
      ConnectNet.__super__.connect.apply(this, arguments);
      this.socket.on('connect', this.onConnect);
      this.socket.on('data', this.onBuffer);
      this.socket.on('end', this.onDisconnect);
      return this.socket.on('error', this.onError);
    };

    ConnectNet.prototype.send = function(message, encoding, callback) {
      var data;
      if (encoding == null) {
        encoding = null;
      }
      if (callback == null) {
        callback = null;
      }
      data = message.join(" ") + "\r\n";
      return this.socket.write(data, encoding, callback);
    };

    ConnectNet.prototype.disconnect = function() {
      this.socket.end();
      return this.onDisconnect();
    };

    ConnectNet.prototype.onConnect = function() {
      this.connected = true;
      this.debug("ConnectNet::onConnect");
      return this.emit('connect');
    };

    ConnectNet.prototype.onBuffer = function(buffer) {
      var line, _i, _len, _ref, _results;
      this.debug('ConnectNet::onBuffer', buffer);
      this.emit('buffer', buffer);
      _ref = buffer.toString().split("\n");
      _results = [];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        line = _ref[_i];
        _results.push(this.handleLine(line));
      }
      return _results;
    };

    ConnectNet.prototype.handleLine = function(line) {
      var message;
      line = line.replace(/^\s+|\s+$/g, "");
      if (!line.length) {
        return false;
      }
      this.debug('ConnectNet::handleLine', line);
      message = protocol.prototype.parseData(line);
      this.debug('protocol::parseData', message);
      this.emit('data', line);
      return this.emit('message', message);
    };

    ConnectNet.prototype.onDisconnect = function() {
      this.debug("ConnectNet::onDisconnect");
      this.connected = false;
      return this.emit('socketDisconnect');
    };

    ConnectNet.prototype.onError = function(error) {
      this.debug("ConnectNet::onError", error);
      return this.emit('error', error);
    };

    return ConnectNet;

  })(ConnectBase);

  ConnectTCP = (function(_super) {

    __extends(ConnectTCP, _super);

    function ConnectTCP() {
      this.connect = __bind(this.connect, this);

      this.handleOptions = __bind(this.handleOptions, this);
      return ConnectTCP.__super__.constructor.apply(this, arguments);
    }

    ConnectTCP.prototype.handleOptions = function() {
      var _base, _base1, _base2, _ref, _ref1, _ref2;
      ConnectTCP.__super__.handleOptions.apply(this, arguments);
      if ((_ref = (_base = this.options).host) == null) {
        _base.host = 'ns-server.epitech.net';
      }
      if ((_ref1 = (_base1 = this.options).port) == null) {
        _base1.port = 4242;
      }
      return (_ref2 = (_base2 = this.options).localAddress) != null ? _ref2 : _base2.localAddress = '0.0.0.0';
    };

    ConnectTCP.prototype.connect = function() {
      this.debug("ConnectTCP::connect");
      this.verbose("Connecting to " + this.options.host + ":" + this.options.port + "...");
      this.socket = require('net').connect({
        port: this.options.port,
        host: this.options.host,
        localAddress: this.options.localAddress
      });
      return ConnectTCP.__super__.connect.apply(this, arguments);
    };

    return ConnectTCP;

  })(ConnectNet);

  ConnectUnixSocket = (function(_super) {

    __extends(ConnectUnixSocket, _super);

    function ConnectUnixSocket() {
      this.connect = __bind(this.connect, this);

      this.handleOptions = __bind(this.handleOptions, this);
      return ConnectUnixSocket.__super__.constructor.apply(this, arguments);
    }

    ConnectUnixSocket.prototype.handleOptions = function() {
      ConnectUnixSocket.__super__.handleOptions.apply(this, arguments);
      if (!(this.options.path != null)) {
        throw new Error('unix socket not specified');
      }
    };

    ConnectUnixSocket.prototype.connect = function() {
      this.debug("ConnectUnixSocket::connect");
      this.verbose("Connecting to " + this.options.path + "...");
      this.socket = require('net').connect({
        path: this.options.path
      });
      return ConnectUnixSocket.__super__.connect.apply(this, arguments);
    };

    return ConnectUnixSocket;

  })(ConnectNet);

  module.exports = {
    unixSocket: ConnectUnixSocket,
    tcp: ConnectTCP,
    net: ConnectNet,
    base: ConnectBase,
    PubSub: PubSub
  };

}).call(this);
